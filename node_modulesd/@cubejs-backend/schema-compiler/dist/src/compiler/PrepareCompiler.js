"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compile = exports.prepareCompiler = void 0;
const CubeValidator_1 = require("./CubeValidator");
const DataSchemaCompiler_1 = require("./DataSchemaCompiler");
const transpilers_1 = require("./transpilers");
const extensions_1 = require("../extensions");
const CubeSymbols_1 = require("./CubeSymbols");
const CubeDictionary_1 = require("./CubeDictionary");
const CubeEvaluator_1 = require("./CubeEvaluator");
const ContextEvaluator_1 = require("./ContextEvaluator");
const JoinGraph_1 = require("./JoinGraph");
const CubeToMetaTransformer_1 = require("./CubeToMetaTransformer");
const CompilerCache_1 = require("./CompilerCache");
const prepareCompiler = (repo, options) => {
    const cubeDictionary = new CubeDictionary_1.CubeDictionary();
    const cubeSymbols = new CubeSymbols_1.CubeSymbols();
    const cubeValidator = new CubeValidator_1.CubeValidator(cubeSymbols);
    const cubeEvaluator = new CubeEvaluator_1.CubeEvaluator(cubeValidator);
    const contextEvaluator = new ContextEvaluator_1.ContextEvaluator(cubeEvaluator);
    const joinGraph = new JoinGraph_1.JoinGraph(cubeValidator, cubeEvaluator);
    const metaTransformer = new CubeToMetaTransformer_1.CubeToMetaTransformer(cubeValidator, cubeEvaluator, contextEvaluator, joinGraph);
    const { maxQueryCacheSize, maxQueryCacheAge } = options;
    const compilerCache = new CompilerCache_1.CompilerCache({ maxQueryCacheSize, maxQueryCacheAge });
    const transpilers = [
        new transpilers_1.ValidationTranspiler(),
        new transpilers_1.ImportExportTranspiler(),
        new transpilers_1.CubePropContextTranspiler(cubeSymbols, cubeDictionary),
    ];
    if (!options.allowJsDuplicatePropsInSchema) {
        transpilers.push(new transpilers_1.CubeCheckDuplicatePropTranspiler());
    }
    const compiler = new DataSchemaCompiler_1.DataSchemaCompiler(repo, Object.assign({}, {
        cubeNameCompilers: [cubeDictionary],
        preTranspileCubeCompilers: [cubeSymbols, cubeValidator],
        transpilers,
        cubeCompilers: [cubeEvaluator, joinGraph, metaTransformer],
        contextCompilers: [contextEvaluator],
        cubeFactory: cubeSymbols.createCube.bind(cubeSymbols),
        compilerCache,
        extensions: {
            Funnels: extensions_1.Funnels,
            RefreshKeys: extensions_1.RefreshKeys,
            Reflection: extensions_1.Reflection
        },
        compileContext: options.compileContext
    }, options));
    return {
        compiler,
        metaTransformer,
        cubeEvaluator,
        contextEvaluator,
        joinGraph,
        compilerCache,
        headCommitId: options.headCommitId
    };
};
exports.prepareCompiler = prepareCompiler;
const compile = (repo, options) => {
    const compilers = exports.prepareCompiler(repo, options);
    return compilers.compiler.compile().then(() => compilers);
};
exports.compile = compile;
//# sourceMappingURL=PrepareCompiler.js.map