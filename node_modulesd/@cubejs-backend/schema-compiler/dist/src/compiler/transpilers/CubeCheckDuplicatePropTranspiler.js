"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CubeCheckDuplicatePropTranspiler = void 0;
class CubeCheckDuplicatePropTranspiler {
    traverseObject(reporter) {
        return {
            CallExpression: path => {
                // @ts-ignore @todo Unsafely?
                if (path.node.callee.name === 'cube') {
                    path.node.arguments.forEach(arg => {
                        if (arg && arg.type === 'ObjectExpression') {
                            this.checkExpression(arg, reporter);
                        }
                    });
                }
            }
        };
    }
    compileExpression(expr) {
        if (expr.type === 'Identifier') {
            return expr.name;
        }
        if (expr.type === 'StringLiteral' && expr.value) {
            return expr.value;
        }
        return null;
    }
    checkExpression(astObjectExpression, reporter) {
        const unique = new Set();
        for (const prop of astObjectExpression.properties) {
            if (prop.type === 'ObjectProperty') {
                if (prop.value && prop.key) {
                    if (prop.value.type === 'ObjectExpression') {
                        this.checkExpression(prop.value, reporter);
                    }
                    const keyName = this.compileExpression(prop.key);
                    if (keyName) {
                        if (unique.has(keyName)) {
                            reporter.syntaxError({
                                message: `Duplicate property parsing ${keyName}`,
                                loc: prop.key.loc,
                            });
                        }
                        unique.add(keyName);
                    }
                }
            }
        }
    }
}
exports.CubeCheckDuplicatePropTranspiler = CubeCheckDuplicatePropTranspiler;
//# sourceMappingURL=CubeCheckDuplicatePropTranspiler.js.map