"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CubeSymbols = void 0;
const ramda_1 = __importDefault(require("ramda"));
const shared_1 = require("@cubejs-backend/shared");
const UserError_1 = require("./UserError");
const DynamicReference_1 = require("./DynamicReference");
const FunctionRegex = /function\s+\w+\(([A-Za-z0-9_,]*)|\(([\s\S]*?)\)\s*=>|\(?(\w+)\)?\s*=>/;
const CONTEXT_SYMBOLS = {
    USER_CONTEXT: 'securityContext',
    SECURITY_CONTEXT: 'securityContext',
    FILTER_PARAMS: 'filterParams',
    SQL_UTILS: 'sqlUtils'
};
const CURRENT_CUBE_CONSTANTS = ['CUBE', 'TABLE'];
class CubeSymbols {
    constructor() {
        this.symbols = {};
        this.builtCubes = {};
        this.cubeDefinitions = {};
        this.funcArgumentsValues = {};
        this.cubeList = [];
    }
    compile(cubes, errorReporter) {
        this.cubeDefinitions = ramda_1.default.pipe(ramda_1.default.map(c => [c.name, c]), ramda_1.default.fromPairs)(cubes);
        this.cubeList = cubes.map(c => (c.name ? this.getCubeDefinition(c.name) : this.createCube(c)));
        this.symbols = ramda_1.default.pipe(ramda_1.default.map((c) => [c.name, this.transform(c.name, errorReporter.inContext(`${c.name} cube`))]), ramda_1.default.fromPairs)(cubes);
    }
    getCubeDefinition(cubeName) {
        if (!this.builtCubes[cubeName]) {
            const cubeDefinition = this.cubeDefinitions[cubeName];
            this.builtCubes[cubeName] = this.createCube(cubeDefinition);
        }
        return this.builtCubes[cubeName];
    }
    createCube(cubeDefinition) {
        const cubeObject = Object.assign({
            allDefinitions(type) {
                let superDefinitions = {};
                if (cubeDefinition.extends) {
                    superDefinitions = super.allDefinitions(type);
                }
                return Object.assign({}, superDefinitions, cubeDefinition[type]);
            },
            get measures() {
                return this.allDefinitions('measures');
            },
            set measures(v) {
                // Dont allow to modify
            },
            get dimensions() {
                return this.allDefinitions('dimensions');
            },
            set dimensions(v) {
                // Dont allow to modify
            },
            get segments() {
                return this.allDefinitions('segments');
            },
            set segments(v) {
                // Dont allow to modify
            }
        }, cubeDefinition);
        if (cubeDefinition.extends) {
            const superCube = this.resolveSymbolsCall(cubeDefinition.extends, (name) => this.cubeReferenceProxy(name));
            Object.setPrototypeOf(cubeObject, 
            // eslint-disable-next-line no-underscore-dangle
            superCube.__cubeName ? this.getCubeDefinition(superCube.__cubeName) : superCube);
        }
        return cubeObject;
    }
    transform(cubeName, errorReporter) {
        const cube = this.getCubeDefinition(cubeName);
        const duplicateNames = ramda_1.default.compose(ramda_1.default.map(nameToDefinitions => nameToDefinitions[0]), ramda_1.default.toPairs, ramda_1.default.filter(definitionsByName => definitionsByName.length > 1), ramda_1.default.groupBy(nameToDefinition => nameToDefinition[0]), ramda_1.default.unnest, ramda_1.default.map(ramda_1.default.toPairs), ramda_1.default.filter(v => !!v))([cube.measures, cube.dimensions, cube.segments, cube.preAggregations]);
        if (duplicateNames.length > 0) {
            errorReporter.error(`${duplicateNames.join(', ')} defined more than once`);
        }
        if (cube.preAggregations) {
            this.transformPreAggregations(cube.preAggregations);
        }
        return Object.assign({ cubeName: () => cube.name }, cube.measures || {}, cube.dimensions || {}, cube.segments || {}, cube.preAggregations || {});
    }
    transformPreAggregations(preAggregations) {
        // eslint-disable-next-line no-restricted-syntax
        for (const preAggregation of Object.values(preAggregations)) {
            // Rollup is a default type for pre-aggregations
            if (!preAggregation.type) {
                preAggregation.type = 'rollup';
            }
            if (preAggregation.scheduledRefresh === undefined) {
                preAggregation.scheduledRefresh = shared_1.getEnv('scheduledRefreshDefault');
            }
            if (preAggregation.external === undefined) {
                preAggregation.external = ['rollup', 'rollupJoin'].includes(preAggregation.type) && shared_1.getEnv('externalDefault');
            }
        }
    }
    resolveSymbolsCall(func, nameResolver, context) {
        const oldContext = this.resolveSymbolsCallContext;
        this.resolveSymbolsCallContext = context;
        try {
            // eslint-disable-next-line prefer-spread
            let res = func.apply(null, this.funcArguments(func).map((id) => nameResolver(id.trim())));
            if (res instanceof DynamicReference_1.DynamicReference) {
                res = res.fn.apply(null, res.memberNames.map((id) => nameResolver(id.trim())));
            }
            return res;
        }
        finally {
            this.resolveSymbolsCallContext = oldContext;
        }
    }
    funcArguments(func) {
        const funcDefinition = func.toString();
        if (!this.funcArgumentsValues[funcDefinition]) {
            const match = funcDefinition.match(FunctionRegex);
            if (match && (match[1] || match[2] || match[3])) {
                this.funcArgumentsValues[funcDefinition] = (match[1] || match[2] || match[3]).split(',').map(s => s.trim());
            }
            else if (match) {
                this.funcArgumentsValues[funcDefinition] = [];
            }
            else {
                throw new Error(`Can't match args for: ${func.toString()}`);
            }
        }
        return this.funcArgumentsValues[funcDefinition];
    }
    resolveSymbol(cubeName, name) {
        const { sqlResolveFn, contextSymbols } = this.resolveSymbolsCallContext || {};
        if (CONTEXT_SYMBOLS[name]) {
            // always resolves if contextSymbols aren't passed for transpile step
            const symbol = contextSymbols && contextSymbols[CONTEXT_SYMBOLS[name]] || {};
            // eslint-disable-next-line no-underscore-dangle
            symbol._objectWithResolvedProperties = true;
            return symbol;
        }
        let cube = this.isCurrentCube(name) && this.symbols[cubeName] || this.symbols[name];
        if (sqlResolveFn && cube) {
            cube = this.cubeReferenceProxy(this.isCurrentCube(name) ? cubeName : name);
        }
        return cube || (this.symbols[cubeName] && this.symbols[cubeName][name]);
    }
    cubeReferenceProxy(cubeName) {
        const self = this;
        return new Proxy({}, {
            get: (v, propertyName) => {
                if (propertyName === '__cubeName') {
                    return cubeName;
                }
                const cube = self.symbols[cubeName];
                // first phase of compilation
                if (!cube) {
                    if (propertyName === 'toString') {
                        return cubeName;
                    }
                    return undefined;
                }
                const { sqlResolveFn, cubeAliasFn, query } = self.resolveSymbolsCallContext || {};
                if (propertyName === 'toString') {
                    return () => cubeAliasFn && cubeAliasFn(cube.cubeName()) || cube.cubeName();
                }
                if (propertyName === 'sql') {
                    return () => query.cubeSql(cube.cubeName());
                }
                if (propertyName === '_objectWithResolvedProperties') {
                    return true;
                }
                if (cube[propertyName]) {
                    return { toString: () => sqlResolveFn(cube[propertyName], cubeName, propertyName) };
                }
                if (typeof propertyName === 'string') {
                    throw new UserError_1.UserError(`${cubeName}.${propertyName} cannot be resolved`);
                }
                return undefined;
            }
        });
    }
    isCurrentCube(name) {
        return CURRENT_CUBE_CONSTANTS.indexOf(name) >= 0;
    }
}
exports.CubeSymbols = CubeSymbols;
//# sourceMappingURL=CubeSymbols.js.map