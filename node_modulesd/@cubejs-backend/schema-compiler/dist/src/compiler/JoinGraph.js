"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.JoinGraph = void 0;
const ramda_1 = __importDefault(require("ramda"));
const node_dijkstra_1 = __importDefault(require("node-dijkstra"));
const UserError_1 = require("./UserError");
class JoinGraph {
    constructor(cubeValidator, cubeEvaluator) {
        this.cubeValidator = cubeValidator;
        this.cubeEvaluator = cubeEvaluator;
        this.nodes = {};
        this.edges = {};
        this.builtJoins = {};
    }
    compile(cubes, errorReporter) {
        this.edges = ramda_1.default.compose(ramda_1.default.fromPairs, ramda_1.default.unnest, ramda_1.default.map(v => this.buildJoinEdges(v, errorReporter.inContext(`${v.name} cube`))), ramda_1.default.filter(this.cubeValidator.isCubeValid.bind(this.cubeValidator)))(this.cubeEvaluator.cubeList);
        this.nodes = ramda_1.default.compose(ramda_1.default.map(groupedByFrom => ramda_1.default.fromPairs(groupedByFrom.map(join => [join.to, 1]))), ramda_1.default.groupBy(join => join.from), ramda_1.default.map(v => v[1]), ramda_1.default.toPairs)(this.edges);
        this.undirectedNodes = ramda_1.default.compose(ramda_1.default.map(groupedByFrom => ramda_1.default.fromPairs(groupedByFrom.map(join => [join.from, 1]))), ramda_1.default.groupBy(join => join.to), ramda_1.default.unnest, ramda_1.default.map(v => [v[1], { from: v[1].to, to: v[1].from }]), ramda_1.default.toPairs)(this.edges);
        this.graph = new node_dijkstra_1.default(this.nodes);
    }
    buildJoinEdges(cube, errorReporter) {
        return ramda_1.default.compose(ramda_1.default.filter(ramda_1.default.identity), ramda_1.default.map(join => {
            const multipliedMeasures = ramda_1.default.compose(ramda_1.default.filter(m => m.sql && this.cubeEvaluator.funcArguments(m.sql).length === 0 && m.sql() === 'count(*)' ||
                ['sum', 'avg', 'count', 'number'].indexOf(m.type) !== -1), ramda_1.default.values);
            const joinRequired = (v) => `primary key for '${v}' is required when join is defined in order to make aggregates work properly`;
            if (!this.cubeEvaluator.primaryKeys[join[1].from] &&
                multipliedMeasures(this.cubeEvaluator.measuresForCube(join[1].from)).length > 0) {
                errorReporter.error(joinRequired(join[1].from));
                return null;
            }
            if (!this.cubeEvaluator.primaryKeys[join[1].to] &&
                multipliedMeasures(this.cubeEvaluator.measuresForCube(join[1].to)).length > 0) {
                errorReporter.error(joinRequired(join[1].to));
                return null;
            }
            return join;
        }), ramda_1.default.unnest, ramda_1.default.map(join => [
            [`${cube.name}-${join[0]}`, {
                    join: join[1],
                    from: cube.name,
                    to: join[0],
                    originalFrom: cube.name,
                    originalTo: join[0]
                }]
        ]), ramda_1.default.filter(ramda_1.default.identity), ramda_1.default.map(join => {
            if (!this.cubeEvaluator.cubeExists(join[0])) {
                errorReporter.error(`Cube ${join[0]} doesn't exist`);
                return undefined;
            }
            return join;
        }), ramda_1.default.toPairs)(cube.joins || {});
    }
    buildJoinNode(cube) {
        return ramda_1.default.compose(ramda_1.default.fromPairs, ramda_1.default.map(v => [v[0], 1]), ramda_1.default.toPairs)(cube.joins || {});
    }
    buildJoin(cubesToJoin) {
        if (!cubesToJoin.length) {
            return null;
        }
        const key = JSON.stringify(cubesToJoin);
        if (!this.builtJoins[key]) {
            const join = ramda_1.default.pipe(ramda_1.default.map(cube => this.buildJoinTreeForRoot(cube, ramda_1.default.without([cube], cubesToJoin))), ramda_1.default.filter(ramda_1.default.identity), ramda_1.default.sortBy(joinTree => joinTree.joins.length))(cubesToJoin)[0];
            if (!join) {
                throw new UserError_1.UserError(`Can't find join path to join ${cubesToJoin.map(v => `'${v}'`).join(', ')}`);
            }
            this.builtJoins[key] = Object.assign(join, {
                multiplicationFactor: ramda_1.default.compose(ramda_1.default.fromPairs, ramda_1.default.map(v => [v, this.findMultiplicationFactorFor(v, join.joins)]))(cubesToJoin)
            });
        }
        return this.builtJoins[key];
    }
    buildJoinTreeForRoot(root, cubesToJoin) {
        const self = this;
        const result = cubesToJoin.map(toJoin => {
            const path = this.graph.path(root, toJoin);
            if (!path) {
                return null;
            }
            const foundJoins = self.joinsByPath(path);
            return { cubes: path, joins: foundJoins };
        }).reduce((joined, res) => {
            if (!res || !joined) {
                return null;
            }
            const indexedPairs = ramda_1.default.compose(ramda_1.default.addIndex(ramda_1.default.map)((j, i) => [i, j]));
            return {
                joins: joined.joins.concat(indexedPairs(res.joins))
            };
        }, { joins: [] });
        if (!result) {
            return null;
        }
        const pairsSortedByIndex = ramda_1.default.compose(ramda_1.default.uniq, ramda_1.default.map(indexToJoin => indexToJoin[1]), ramda_1.default.sortBy(indexToJoin => indexToJoin[0]));
        return {
            joins: pairsSortedByIndex(result.joins),
            root
        };
    }
    findMultiplicationFactorFor(cube, joins) {
        const visited = {};
        const self = this;
        function findIfMultipliedRecursive(currentCube) {
            if (visited[currentCube]) {
                return false;
            }
            visited[currentCube] = true;
            function nextNode(nextJoin) {
                return nextJoin.from === currentCube ? nextJoin.to : nextJoin.from;
            }
            const nextJoins = joins.filter(j => j.from === currentCube || j.to === currentCube);
            if (nextJoins.find(nextJoin => self.checkIfCubeMultiplied(currentCube, nextJoin) && !visited[nextNode(nextJoin)])) {
                return true;
            }
            return !!nextJoins.find(nextJoin => findIfMultipliedRecursive(nextNode(nextJoin)));
        }
        return findIfMultipliedRecursive(cube);
    }
    checkIfCubeMultiplied(cube, join) {
        return join.from === cube && join.join.relationship === 'hasMany' ||
            join.to === cube && join.join.relationship === 'belongsTo';
    }
    joinsByPath(path) {
        return ramda_1.default.range(0, path.length - 1).map(i => this.edges[`${path[i]}-${path[i + 1]}`]);
    }
    connectedComponents() {
        if (!this.cachedConnectedComponents) {
            let componentId = 1;
            const components = {};
            ramda_1.default.toPairs(this.nodes).map(nameToConnection => nameToConnection[0]).forEach(node => {
                this.findConnectedComponent(componentId, node, components);
                componentId += 1;
            });
            this.cachedConnectedComponents = components;
        }
        return this.cachedConnectedComponents;
    }
    findConnectedComponent(componentId, node, components) {
        if (!components[node]) {
            components[node] = componentId;
            ramda_1.default.toPairs(this.undirectedNodes[node])
                .map(connectedNodeNames => connectedNodeNames[0])
                .forEach(connectedNode => {
                this.findConnectedComponent(componentId, connectedNode, components);
            });
        }
    }
}
exports.JoinGraph = JoinGraph;
//# sourceMappingURL=JoinGraph.js.map