"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTimeDimension = void 0;
const moment_timezone_1 = __importDefault(require("moment-timezone"));
const moment_range_1 = require("moment-range");
const shared_1 = require("@cubejs-backend/shared");
const BaseFilter_1 = require("./BaseFilter");
const UserError_1 = require("../compiler/UserError");
const moment = moment_range_1.extendMoment(moment_timezone_1.default);
class BaseTimeDimension extends BaseFilter_1.BaseFilter {
    constructor(query, timeDimension) {
        super(query, {
            dimension: timeDimension.dimension,
            operator: 'in_date_range',
            values: timeDimension.dateRange
        });
        this.query = query;
        this.dateRange = timeDimension.dateRange;
        this.granularity = timeDimension.granularity;
        this.boundaryDateRange = timeDimension.boundaryDateRange;
    }
    selectColumns() {
        const context = this.query.safeEvaluateSymbolContext();
        if (!context.granularityOverride && !this.granularity) {
            return null;
        }
        return super.selectColumns();
    }
    aliasName() {
        const context = this.query.safeEvaluateSymbolContext();
        if (!context.granularityOverride && !this.granularity) {
            return null;
        }
        return super.aliasName();
    }
    unescapedAliasName(granularity) {
        const actualGranularity = granularity || this.granularity || 'day';
        return `${this.query.aliasName(this.dimension)}_${actualGranularity}`; // TODO date here for rollups
    }
    dateSeriesAliasName() {
        return this.query.escapeColumnName(`${this.dimension}_series`);
    }
    dateSeriesSelectColumn(dateSeriesAliasName) {
        if (!this.granularity) {
            return null;
        }
        return `${dateSeriesAliasName || this.dateSeriesAliasName()}.${this.query.escapeColumnName('date_from')} ${this.aliasName()}`;
    }
    dimensionSql() {
        const context = this.query.safeEvaluateSymbolContext();
        const granularity = context.granularityOverride || this.granularity;
        if (context.rollupQuery || context.wrapQuery) {
            if (context.rollupGranularity === this.granularity) {
                return super.dimensionSql();
            }
            return this.query.timeGroupedColumn(granularity, this.query.dimensionSql(this));
        }
        if (context.ungrouped) {
            return this.convertedToTz();
        }
        return this.query.timeGroupedColumn(granularity, this.convertedToTz());
    }
    convertedToTz() {
        return this.query.convertTz(this.query.dimensionSql(this));
    }
    filterToWhere() {
        if (!this.dateRange) {
            return null;
        }
        return super.filterToWhere();
    }
    filterParams() {
        if (!this.dateRange) {
            return [];
        }
        return super.filterParams();
    }
    dateFromFormatted() {
        if (!this.dateFromFormattedValue) {
            this.dateFromFormattedValue = this.formatFromDate(this.dateRange[0]);
        }
        return this.dateFromFormattedValue;
    }
    dateFrom() {
        if (!this.dateFromValue) {
            this.dateFromValue = this.inDbTimeZoneDateFrom(this.dateRange[0]);
        }
        return this.dateFromValue;
    }
    dateFromParam() {
        return this.query.paramAllocator.allocateParamsForQuestionString(this.query.timeStampParam(this), [this.dateFrom()]);
    }
    localDateTimeFromParam() {
        return this.query.dateTimeCast(this.query.paramAllocator.allocateParam(this.dateFromFormatted()));
    }
    localDateTimeFromOrBuildRangeParam() {
        return this.query.dateTimeCast(this.query.paramAllocator.allocateParam(this.dateRange ? this.dateFromFormatted() : shared_1.BUILD_RANGE_START_LOCAL));
    }
    dateToFormatted() {
        if (!this.dateToFormattedValue) {
            this.dateToFormattedValue = this.formatToDate(this.dateRange[1]);
        }
        return this.dateToFormattedValue;
    }
    dateTo() {
        if (!this.dateToValue) {
            this.dateToValue = this.inDbTimeZoneDateTo(this.dateRange[1]);
        }
        return this.dateToValue;
    }
    dateToParam() {
        return this.query.paramAllocator.allocateParamsForQuestionString(this.query.timeStampParam(this), [this.dateTo()]);
    }
    localDateTimeToParam() {
        return this.query.dateTimeCast(this.query.paramAllocator.allocateParam(this.dateToFormatted()));
    }
    localDateTimeToOrBuildRangeParam() {
        return this.query.dateTimeCast(this.query.paramAllocator.allocateParam(this.dateRange ? this.dateToFormatted() : shared_1.BUILD_RANGE_END_LOCAL));
    }
    dateRangeGranularity() {
        if (!this.dateRange) {
            return null;
        }
        const msFrom = moment.tz(this.dateFromFormatted(), this.query.timezone);
        const msTo = moment.tz(this.dateToFormatted(), this.query.timezone).add(1, 'ms');
        return this.query.minGranularity(this.query.granularityFor(msFrom), this.query.granularityFor(msTo));
    }
    rollupGranularity() {
        if (!this.rollupGranularityValue) {
            this.rollupGranularityValue =
                this.query.cacheValue(['rollupGranularity', this.granularity].concat(this.dateRange), () => this.query.minGranularity(this.granularity, this.dateRangeGranularity()));
        }
        return this.rollupGranularityValue;
    }
    timeSeries() {
        if (!this.dateRange) {
            throw new UserError_1.UserError('Time series queries without dateRange aren\'t supported');
        }
        if (!this.granularity) {
            return [
                [this.dateFromFormatted(), this.dateToFormatted()]
            ];
        }
        return shared_1.timeSeries(this.granularity, [this.dateFromFormatted(), this.dateToFormatted()]);
    }
    wildcardRange() {
        return [shared_1.FROM_PARTITION_RANGE, shared_1.TO_PARTITION_RANGE];
    }
    boundaryDateRangeFormatted() {
        // TODO or here is due to boundaryDateRange can be defined in originalSql query used by rollup
        // TODO and dateRange can be defined in rollup query
        return this.boundaryDateRange && [
            this.formatFromDate(this.boundaryDateRange[0]),
            this.formatToDate(this.boundaryDateRange[1])
        ] || [this.dateFromFormatted(), this.dateToFormatted()];
    }
}
exports.BaseTimeDimension = BaseTimeDimension;
//# sourceMappingURL=BaseTimeDimension.js.map