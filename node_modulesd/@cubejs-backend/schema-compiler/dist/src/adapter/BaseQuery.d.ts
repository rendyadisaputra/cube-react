export class BaseQuery {
    constructor(compilers: any, options: any);
    compilers: any;
    cubeEvaluator: any;
    joinGraph: any;
    options: any;
    orderHashToString(hash: any): string | null;
    defaultOrder(): {
        id: any;
        desc: boolean;
    }[];
    extractDimensionsAndMeasures(filters?: any[]): any[];
    extractFiltersAsTree(filters?: any[]): any;
    initFromOptions(): void;
    contextSymbols: any;
    /**
     * @protected
     * @type {ParamAllocator}
     */
    protected paramAllocator: ParamAllocator | undefined;
    compilerCache: any;
    queryCache: any;
    timezone: any;
    rowLimit: any;
    offset: any;
    preAggregations: PreAggregations | undefined;
    measures: any;
    dimensions: any;
    segments: any;
    order: any;
    filters: any;
    measureFilters: any;
    timeDimensions: any;
    allFilters: any;
    join: any;
    cubeAliasPrefix: any;
    preAggregationsSchemaOption: any;
    externalQueryClass: any;
    cacheValue(key: any, fn: any, { contextPropNames, inputProps, cache }?: {
        contextPropNames: any;
        inputProps: any;
        cache: any;
    }): any;
    get allCubeNames(): any;
    collectedCubeNames: any;
    get dataSource(): any;
    cubeDataSource(cube: any): any;
    get aliasNameToMember(): {
        [index: string]: any;
    };
    initUngrouped(): void;
    ungrouped: any;
    get subQueryDimensions(): any;
    _subQueryDimensions: any;
    get asSyntaxTable(): string;
    get asSyntaxJoin(): string;
    newMeasure(measurePath: any): BaseMeasure;
    newDimension(dimensionPath: any): BaseDimension;
    newSegment(segmentPath: any): BaseSegment;
    initFilter(filter: any): BaseGroupFilter | BaseFilter;
    newFilter(filter: any): BaseFilter;
    newGroupFilter(filter: any): BaseGroupFilter;
    newTimeDimension(timeDimension: any): BaseTimeDimension;
    newParamAllocator(): ParamAllocator;
    newPreAggregations(): PreAggregations;
    escapeColumnName(name: any): string;
    buildParamAnnotatedSql(): any;
    regularAndTimeSeriesRollupQuery(regularMeasures: any, multipliedMeasures: any, cumulativeMeasures: any, preAggregationForQuery: any): string;
    externalPreAggregationQuery(): boolean;
    buildSqlAndParams(): any;
    externalQuery(): any;
    runningTotalDateJoinCondition(): any;
    rollingWindowDateJoinCondition(trailingInterval: any, leadingInterval: any, offset: any): any;
    subtractInterval(date: any, interval: any): string;
    addInterval(date: any, interval: any): string;
    addTimestampInterval(timestamp: any, interval: any): string;
    subtractTimestampInterval(timestamp: any, interval: any): string;
    cumulativeMeasures(): any;
    isRolling(): boolean;
    simpleQuery(): string;
    fullKeyQueryAggregate(): string;
    joinFullKeyQueryAggregate(multipliedMeasures: any, regularMeasures: any, cumulativeMeasures: any, toJoin: any): string;
    fullKeyQueryAggregateMeasures(): {
        multipliedMeasures: BaseMeasure[];
        regularMeasures: BaseMeasure[];
        cumulativeMeasures: R.KeyValuePair<any, BaseMeasure>[];
    };
    dimensionsJoinCondition(leftAlias: any, rightAlias: any): string;
    baseWhere(filters: any): string;
    baseHaving(filters: any): string;
    timeStampInClientTz(dateParam: any): string;
    granularityHierarchies(): {
        [index: string]: any;
    };
    granularityParentHierarchy(granularity: any): any;
    minGranularity(granularityA: any, granularityB: any): any;
    overTimeSeriesQuery(baseQueryFn: any, cumulativeMeasure: any, fromRollup: any): any;
    dateFromStartToEndConditionSql(dateJoinCondition: any, fromRollup: any, isFromStartToEnd: any): any;
    overTimeSeriesSelect(cumulativeMeasures: any, dateSeriesSql: any, baseQuery: any, dateJoinConditionSql: any, baseQueryAlias: any): string;
    overTimeSeriesForSelect(cumulativeMeasures: any): any;
    dateSeriesSelect(): any;
    dateSeriesSql(timeDimension: any): string;
    seriesSql(timeDimension: any): string;
    /**
     * @param {string} timeDimension
     * @return {string}
     */
    timeStampParam(timeDimension: string): string;
    timeRangeFilter(dimensionSql: any, fromTimeStampParam: any, toTimeStampParam: any): string;
    timeNotInRangeFilter(dimensionSql: any, fromTimeStampParam: any, toTimeStampParam: any): string;
    beforeDateFilter(dimensionSql: any, timeStampParam: any): string;
    afterDateFilter(dimensionSql: any, timeStampParam: any): string;
    timeStampCast(value: any): string;
    dateTimeCast(value: any): string;
    commonQuery(): string;
    collectRootMeasureToHieararchy(): {
        [index: string]: any;
    };
    query(): string;
    rewriteInlineCubeSql(cube: any, isLeftJoinCondition: any): any[];
    joinQuery(join: any, subQueryDimensions: any): string;
    joinSql(toJoin: any): string;
    subQueryJoin(dimension: any): {
        sql: string;
        alias: string;
        on: string;
    };
    get filtersWithoutSubQueries(): any;
    filtersWithoutSubQueriesValue: any;
    subQueryDescription(dimension: any): {
        prefix: string;
        subQuery: any;
        cubeName: any;
    };
    subQueryName(cubeName: any, name: any): string;
    regularMeasuresSubQuery(measures: any, filters: any): string;
    aggregateSubQuery(keyCubeName: any, measures: any, filters: any): string;
    checkShouldBuildJoinForMeasureSelect(measures: any, keyCubeName: any): any;
    aggregateSubQueryMeasureJoin(keyCubeName: any, measures: any, measuresJoin: any, primaryKeyDimension: any, measureSubQueryDimensions: any): any;
    groupedUngroupedSelect(select: any, ungrouped: any, granularityOverride: any): any;
    ungroupedMeasureSelect(select: any): any;
    keysQuery(primaryKeyDimension: any, filters: any): string;
    keysSelect(primaryKeyDimension: any): string;
    keyDimensions(primaryKeyDimension: any): any;
    cubeSql(cube: any): any;
    traverseSymbol(s: any): any;
    collectCubeNames(excludeTimeDimensions: any): any;
    collectFromMembers(excludeTimeDimensions: any, fn: any, methodName: any): any;
    collectFrom(membersToCollectFrom: any, fn: any, methodName: any, cache: any): any[];
    collectSubQueryDimensionsFor(fn: any): never[];
    rewriteInlineWhere(fn: any, inlineWhereConditions: any): any;
    groupByClause(): string;
    getFieldIndex(id: any): any;
    orderBy(): string;
    dimensionAliasNames(): any[];
    dimensionColumns(cubeAlias: any): string[];
    groupByDimensionLimit(): string;
    topLimit(): string;
    baseSelect(): string;
    selectAllDimensionsAndMeasures(measures: any): string;
    forSelect(): any;
    dimensionsForSelect(): any;
    dimensionSql(dimension: any): any;
    segmentSql(segment: any): any;
    measureSql(measure: any): any;
    autoPrefixWithCubeName(cubeName: any, sql: any): any;
    wrapSegmentForDimensionSelect(sql: any): any;
    pushCubeNameForCollectionIfNecessary(cubeName: any): void;
    pushMemberNameForCollectionIfNecessary(cubeName: any, name: any): void;
    safeEvaluateSymbolContext(): any;
    evaluateSymbolSql(cubeName: any, name: any, symbol: any): any;
    autoPrefixAndEvaluateSql(cubeName: any, sql: any): any;
    concatStringsSql(strings: any): any;
    primaryKeyName(cubeName: any): string;
    evaluateSql(cubeName: any, sql: any, options: any): any;
    withCubeAliasPrefix(cubeAliasPrefix: any, fn: any): any;
    cubeAlias(cubeName: any): string;
    collectCubeNamesFor(fn: any): never[];
    collectMemberNamesFor(fn: any): never[];
    collectMultipliedMeasures(fn: any): any[];
    collectLeafMeasures(fn: any): unknown[];
    evaluateSymbolSqlWithContext(fn: any, context: any): any;
    evaluateSymbolContext: any;
    renderSqlMeasure(name: any, evaluateSql: any, symbol: any, cubeName: any, parentMeasure: any): any;
    aggregateOnGroupedColumn(symbol: any, evaluateSql: any, topLevelMerge: any, measurePath: any): string | void;
    topAggregateWrap(symbol: any, evaluateSql: any): any;
    hllInit(sql: any): void;
    hllMerge(sql: any): void;
    hllCardinality(sql: any): void;
    hllMergeOnly(sql: any): void;
    hllCardinalityMerge(sql: any): void;
    countDistinctApprox(sql: any): void;
    primaryKeyCount(cubeName: any, distinct: any): any;
    renderDimensionCase(symbol: any, cubeName: any): string;
    renderDimensionCaseLabel(label: any, cubeName: any): any;
    caseWhenStatement(when: any, elseLabel: any): string;
    applyMeasureFilters(evaluateSql: any, symbol: any, cubeName: any): any;
    evaluateMeasureFilters(symbol: any, cubeName: any): any;
    evaluateFiltersArray(filtersArray: any, cubeName: any): any;
    primaryKeySql(primaryKeyName: any, cubeName: any): any;
    multipliedJoinRowResult(cubeName: any): any;
    inIntegrationTimeZone(date: any): moment.Moment;
    inDbTimeZone(date: any): string;
    /**
     * @return {string}
     */
    timestampFormat(): string;
    /**
     * @param {string} field
     * @return {string}
     */
    convertTz(field: string): string;
    timeGroupedColumn(granularity: any, dimension: any): void;
    aliasName(name: any, isPreAggregationName: any): string;
    newSubQuery(options: any): any;
    cacheKeyQueries(transformFn: any): any;
    refreshKeysByCubes(cubes: any, transformFn: any): any;
    aggSelectForDimension(cube: any, dimension: any, aggFunction: any): string | null;
    cubeCardinalityQueries(): {
        [index: string]: any;
    };
    renewalThreshold(refreshKeyAllSetManually: any): number;
    nowTimestampSql(): string;
    unixTimestampSql(): string;
    preAggregationTableName(cube: any, preAggregationName: any, skipSchema: any): string;
    preAggregationSchema(): any;
    preAggregationLoadSql(cube: any, preAggregation: any, tableName: any): any[];
    preAggregationPreviewSql(tableName: any): [string, unknown[]];
    indexSql(cube: any, preAggregation: any, index: any, indexName: any, tableName: any): any;
    evaluateIndexColumns(cube: any, index: any): any;
    createIndexSql(indexName: any, tableName: any, escapedColumns: any): string;
    preAggregationSql(cube: any, preAggregation: any): any;
    preAggregationQueryForSqlEvaluation(cube: any, preAggregation: any): any;
    parseCronSyntax(every: any): {
        start: cronParser.CronDate;
        end: cronParser.CronDate;
        dayOffset: number;
    };
    calcIntervalForCronString(refreshKey: any): {
        utcOffset: number;
        interval: number;
        dayOffset: number;
    };
    everyRefreshKeySql(refreshKey: any, external?: boolean): any;
    granularityFor(momentDate: any): "day" | "week" | "year" | "month" | "hour" | "minute" | "second";
    /**
     * @protected
     * @param {string} interval
     * @return {(number|*)[]}
     */
    protected parseInterval(interval: string): (number | any)[];
    parseSecondDuration(interval: any): number;
    floorSql(numeric: any): string;
    incrementalRefreshKey(query: any, originalRefreshKey: any, options?: {}): any;
    defaultRefreshKeyRenewalThreshold(): number;
    defaultEveryRefreshKey(): {
        every: string;
    };
    /**
     * Some databases can return dynamically column name, for example Cube Store
     *
     * SELECT FLOOR((UNIX_TIMESTAMP()) / 60);
     * +-------------------------------------------+
     * | floor(Int64(1625395697) Divide Int64(60)) |
     * +-------------------------------------------+
     * | 27089928                                  |
     * +-------------------------------------------+
     * 1 row in set (0.00 sec)
     *
     * @protected
     *
     * @param {string} sql
     * @return {string}
     */
    protected refreshKeySelect(sql: string): string;
    preAggregationInvalidateKeyQueries(cube: any, preAggregation: any): any;
    refreshKeyRenewalThresholdForInterval(refreshKey: any, limitedWithMax?: boolean): number;
    preAggregationStartEndQueries(cube: any, preAggregation: any): any;
    parametrizedContextSymbols(): any;
    parametrizedContextSymbolsValue: any;
    contextSymbolsProxy(symbols: any): any;
    filtersProxy(): {};
}
import { ParamAllocator } from "./ParamAllocator";
import { PreAggregations } from "./PreAggregations";
import { BaseMeasure } from "./BaseMeasure";
import { BaseDimension } from "./BaseDimension";
import { BaseSegment } from "./BaseSegment";
import { BaseGroupFilter } from "./BaseGroupFilter";
import { BaseFilter } from "./BaseFilter";
import { BaseTimeDimension } from "./BaseTimeDimension";
import R from "ramda";
import moment from "moment-timezone";
import cronParser from "cron-parser";
//# sourceMappingURL=BaseQuery.d.ts.map