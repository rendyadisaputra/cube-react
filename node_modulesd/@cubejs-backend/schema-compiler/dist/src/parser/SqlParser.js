"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlParser = void 0;
/* eslint-disable no-underscore-dangle */
const ramda_1 = __importDefault(require("ramda"));
const antlr4ts_1 = require("antlr4ts");
const GenericSqlLexer_1 = require("./GenericSqlLexer");
const GenericSqlParser_1 = require("./GenericSqlParser");
const UserError_1 = require("../compiler/UserError");
const nodeVisitor = (visitor) => ({
    visit: () => {
        //
    },
    visitTerminal: () => {
        //
    },
    visitErrorNode: () => {
        //
    },
    visitChildren(node) {
        if (!node) {
            return;
        }
        visitor.visitNode(node);
        for (let i = 0; i < node.childCount; i++) {
            const child = node.getChild(i);
            if (child && child.childCount) {
                child.accept(this);
            }
        }
    }
});
class SqlParser {
    constructor(sql) {
        this.sql = sql;
        this.errors = [];
        this.ast = this.parse();
    }
    static sqlUpperCase(sql) {
        let result = '';
        let openChar;
        for (let i = 0; i < sql.length; i++) {
            if (openChar) {
                if (openChar === '\'' && sql[i] === openChar && sql[i + 1] === openChar) {
                    result += sql[i];
                    i++;
                }
                else if (sql[i] === openChar) {
                    openChar = null;
                }
                result += sql[i];
            }
            else {
                if (sql[i] === '\'' || sql[i] === '"' || sql[i] === '`') {
                    openChar = sql[i];
                }
                result += sql[i].toUpperCase();
            }
        }
        if (openChar) {
            throw new Error(`Unterminated string: ${sql}`);
        }
        return result;
    }
    parse() {
        const { sql } = this;
        const chars = antlr4ts_1.CharStreams.fromString(SqlParser.sqlUpperCase(sql));
        chars.getText = (interval) => {
            const start = interval.a;
            let stop = interval.b;
            if (stop >= chars.size) {
                stop = chars.size - 1;
            }
            if (start >= chars.size) {
                return '';
            }
            else {
                return sql.slice(start, stop + 1);
            }
        };
        const { errors } = this;
        class ExprErrorListener {
            syntaxError(recognizer, offendingSymbol, line, column, msg, err) {
                errors.push({
                    msg, column, err, line, recognizer, offendingSymbol
                });
            }
        }
        const lexer = new GenericSqlLexer_1.GenericSqlLexer(chars);
        lexer.removeErrorListeners();
        lexer.addErrorListener(new ExprErrorListener());
        const parser = new GenericSqlParser_1.GenericSqlParser(new antlr4ts_1.CommonTokenStream(lexer));
        parser.buildParseTree = true;
        parser.removeErrorListeners();
        parser.addErrorListener(new ExprErrorListener());
        return parser.statement();
    }
    canParse() {
        return !this.errors.length;
    }
    throwErrorsIfAny() {
        if (this.errors.length) {
            throw new UserError_1.UserError(`SQL Parsing Error:\n${this.errors.map(({ msg, column, line }) => `${line}:${column} ${msg}`).join('\n')}`);
        }
    }
    isSimpleAsteriskQuery() {
        if (!this.canParse()) {
            return false;
        }
        let result = false;
        this.ast.accept(nodeVisitor({
            visitNode(ctx) {
                if (ctx instanceof GenericSqlParser_1.QueryContext) {
                    const selectItems = ctx.tryGetRuleContext(0, GenericSqlParser_1.SelectFieldsContext);
                    if (selectItems && selectItems.text === '*') {
                        result = true;
                    }
                }
            }
        }));
        return result;
    }
    extractWhereConditions(tableAlias) {
        this.throwErrorsIfAny();
        let result = '';
        const { sql } = this;
        let cursor = 0;
        let end = 0;
        let originalAlias;
        const whereBuildingVisitor = nodeVisitor({
            visitNode(ctx) {
                var _a, _b, _c, _d, _e;
                if (ctx instanceof GenericSqlParser_1.IdPathContext) {
                    result += sql.substring(cursor, ctx.start.startIndex);
                    cursor = ctx.start.startIndex;
                    const child = ctx.getChild(0);
                    if (child && child.text === originalAlias) {
                        const withoutFirst = ramda_1.default.drop(1, ctx.children);
                        result += [tableAlias].concat(withoutFirst.map(c => c.text)).join('');
                        cursor = ((_a = ctx.stop) === null || _a === void 0 ? void 0 : _a.stopIndex) + 1;
                    }
                    else if (ctx.childCount === 1) {
                        result += [tableAlias, '.'].concat((_b = ctx.children) === null || _b === void 0 ? void 0 : _b.map(c => c.text)).join('');
                        cursor = ((_c = ctx.stop) === null || _c === void 0 ? void 0 : _c.stopIndex) + 1;
                    }
                    else {
                        result += sql.substring(cursor, (_d = ctx.stop) === null || _d === void 0 ? void 0 : _d.stopIndex);
                        cursor = (_e = ctx.stop) === null || _e === void 0 ? void 0 : _e.stopIndex;
                    }
                }
            }
        });
        this.ast.accept(nodeVisitor({
            visitNode(ctx) {
                var _a;
                if (ctx instanceof GenericSqlParser_1.QueryContext && ctx._from && ctx._where) {
                    const aliasField = ctx._from.getRuleContext(0, GenericSqlParser_1.AliasFieldContext);
                    const lastNode = aliasField.getChild(aliasField.childCount - 1);
                    if (lastNode instanceof GenericSqlParser_1.IdPathContext) {
                        originalAlias = lastNode.getChild(lastNode.childCount - 1).text;
                    }
                    else {
                        originalAlias = lastNode.text;
                    }
                    cursor = ctx._where.start.startIndex;
                    end = ((_a = ctx._where.stop) === null || _a === void 0 ? void 0 : _a.stopIndex) + 1;
                    ctx._where.accept(whereBuildingVisitor);
                }
            }
        }));
        result += sql.substring(cursor, end);
        return result;
    }
    extractTableFrom() {
        this.throwErrorsIfAny();
        let result = null;
        this.ast.accept(nodeVisitor({
            visitNode(ctx) {
                if (ctx instanceof GenericSqlParser_1.QueryContext && ctx._from) {
                    const aliasField = ctx._from.getRuleContext(0, GenericSqlParser_1.AliasFieldContext);
                    result = aliasField.getChild(0).text;
                }
            }
        }));
        return result;
    }
}
exports.SqlParser = SqlParser;
//# sourceMappingURL=SqlParser.js.map