import type { Response, Application as ExpressApplication, RequestHandler, ErrorRequestHandler } from 'express';
import { SubscriptionServer, WebSocketSendMessageFn } from './SubscriptionServer';
import { CheckAuthFn, CheckAuthMiddlewareFn, ExtendContextFn, QueryRewriteFn, RequestContext, RequestLoggerMiddlewareFn, Request, ExtendedRequestContext, JWTOptions, SecurityContextExtractorFn } from './interfaces';
import { SQLServer } from './sql-server';
declare type ResponseResultFn = (message: Record<string, any> | Record<string, any>[], extra?: {
    status: number;
}) => void;
declare type CheckAuthInternalOptions = {
    isPlaygroundCheckAuth: boolean;
};
export declare type UserBackgroundContext = {
    authInfo?: any;
    securityContext: any;
};
declare type BaseRequest = {
    context: RequestContext;
    res: ResponseResultFn;
};
declare type QueryRequest = BaseRequest & {
    query: Record<string, any> | Record<string, any>[];
    queryType?: 'multi';
};
export interface ApiGatewayOptions {
    standalone: boolean;
    dataSourceStorage: any;
    refreshScheduler: any;
    scheduledRefreshContexts?: () => Promise<UserBackgroundContext[]>;
    scheduledRefreshTimeZones?: String[];
    basePath: string;
    extendContext?: ExtendContextFn;
    checkAuth?: CheckAuthFn;
    checkAuthMiddleware?: CheckAuthMiddlewareFn;
    jwt?: JWTOptions;
    requestLoggerMiddleware?: RequestLoggerMiddlewareFn;
    queryRewrite?: QueryRewriteFn;
    subscriptionStore?: any;
    enforceSecurityChecks?: boolean;
    playgroundAuthSecret?: string;
    serverCoreVersion?: string;
}
export declare class ApiGateway {
    protected readonly apiSecret: string;
    protected readonly compilerApi: any;
    protected readonly adapterApi: any;
    protected readonly logger: any;
    protected readonly options: ApiGatewayOptions;
    protected readonly refreshScheduler: any;
    protected readonly scheduledRefreshContexts: ApiGatewayOptions['scheduledRefreshContexts'];
    protected readonly scheduledRefreshTimeZones: ApiGatewayOptions['scheduledRefreshTimeZones'];
    protected readonly basePath: string;
    protected readonly queryRewrite: QueryRewriteFn;
    protected readonly subscriptionStore: any;
    protected readonly enforceSecurityChecks: boolean;
    protected readonly standalone: boolean;
    protected readonly extendContext?: ExtendContextFn;
    protected readonly dataSourceStorage: any;
    readonly checkAuthFn: CheckAuthFn;
    readonly checkAuthSystemFn: CheckAuthFn;
    protected readonly checkAuthMiddleware: CheckAuthMiddlewareFn;
    protected readonly requestLoggerMiddleware: RequestLoggerMiddlewareFn;
    protected readonly securityContextExtractor: SecurityContextExtractorFn;
    protected readonly releaseListeners: (() => any)[];
    protected readonly playgroundAuthSecret?: string;
    constructor(apiSecret: string, compilerApi: any, adapterApi: any, logger: any, options: ApiGatewayOptions);
    initApp(app: ExpressApplication): void;
    initSQLServer(): SQLServer;
    initSubscriptionServer(sendMessage: WebSocketSendMessageFn): SubscriptionServer;
    protected duration(requestStarted: any): any;
    runScheduledRefresh({ context, res, queryingOptions }: {
        context: RequestContext;
        res: ResponseResultFn;
        queryingOptions: any;
    }): Promise<void>;
    meta({ context, res }: {
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    getPreAggregations({ context, res }: {
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    getPreAggregationPartitions({ query, context, res }: {
        query: any;
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    getPreAggregationPreview({ query, context, res }: {
        query: any;
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    buildPreAggregations({ query, context, res }: {
        query: any;
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    getPreAggregationsInQueue({ context, res }: {
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    cancelPreAggregationsFromQueue({ query, context, res }: {
        query: any;
        context: RequestContext;
        res: ResponseResultFn;
    }): Promise<void>;
    protected getNormalizedQueries(query: any, context: RequestContext): Promise<any>;
    sql({ query, context, res }: QueryRequest): Promise<void>;
    protected createSecurityContextExtractor(options?: JWTOptions): SecurityContextExtractorFn;
    protected coerceForSqlQuery(query: any, context: Readonly<RequestContext>): any;
    protected dryRun({ query, context, res }: QueryRequest): Promise<void>;
    load({ query, context, res, ...props }: QueryRequest): Promise<void>;
    subscribeQueueEvents({ context, signedWithPlaygroundAuthSecret, connectionId, res }: {
        context: any;
        signedWithPlaygroundAuthSecret: any;
        connectionId: any;
        res: any;
    }): any;
    unSubscribeQueueEvents({ context, connectionId }: {
        context: any;
        connectionId: any;
    }): any;
    subscribe({ query, context, res, subscribe, subscriptionState, queryType }: {
        query: any;
        context: any;
        res: any;
        subscribe: any;
        subscriptionState: any;
        queryType: any;
    }): Promise<void>;
    protected resToResultFn(res: Response): (message: any, { status }?: {
        status?: number | undefined;
    }) => Response<any, Record<string, any>>;
    protected parseQueryParam(query: any): any;
    protected getCompilerApi(context: any): any;
    protected getAdapterApi(context: any): any;
    contextByReq(req: Request, securityContext: any, requestId: string): Promise<ExtendedRequestContext>;
    protected handleErrorMiddleware: ErrorRequestHandler;
    handleError({ e, context, query, res, requestStarted }: any): void;
    protected wrapCheckAuthMiddleware(fn: CheckAuthMiddlewareFn): CheckAuthMiddlewareFn;
    protected wrapCheckAuth(fn: CheckAuthFn): CheckAuthFn;
    protected createDefaultCheckAuth(options?: JWTOptions, internalOptions?: CheckAuthInternalOptions): CheckAuthFn;
    protected createCheckAuthFn(options: ApiGatewayOptions): CheckAuthFn;
    protected createCheckAuthSystemFn(): CheckAuthFn;
    protected extractAuthorizationHeaderWithSchema(req: Request): string | undefined;
    protected checkAuthWrapper(checkAuthFn: CheckAuthFn, req: Request, res: Response, next: any): Promise<void>;
    protected checkAuth: RequestHandler;
    protected checkAuthSystemMiddleware: RequestHandler;
    protected requestContextMiddleware: RequestHandler;
    protected requestLogger: RequestHandler;
    protected compareDateRangeTransformer(query: any): any;
    protected log(event: {
        type: string;
        [key: string]: any;
    }, context?: RequestContext): void;
    protected healthResponse(res: Response, health: 'HEALTH' | 'DOWN'): void;
    protected createSystemContextHandler: (basePath: string) => RequestHandler;
    protected readiness: RequestHandler;
    protected liveness: RequestHandler;
    release(): void;
}
export {};
//# sourceMappingURL=gateway.d.ts.map