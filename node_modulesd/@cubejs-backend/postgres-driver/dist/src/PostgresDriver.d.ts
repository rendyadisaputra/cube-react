import { Pool, PoolConfig, PoolClient, FieldDef } from 'pg';
import { TypeId, TypeFormat } from 'pg-types';
import { BaseDriver, DownloadQueryResultsOptions, DownloadTableMemoryData, DriverInterface, GenericDataBaseType, IndexesSQL, TableStructure, StreamOptions, StreamTableDataWithTypes, QueryOptions } from '@cubejs-backend/query-orchestrator';
export declare type PostgresDriverConfiguration = Partial<PoolConfig> & {
    storeTimezone?: string;
    executionTimeout?: number;
    readOnly?: boolean;
};
export declare class PostgresDriver<Config extends PostgresDriverConfiguration = PostgresDriverConfiguration> extends BaseDriver implements DriverInterface {
    protected readonly pool: Pool;
    protected readonly config: Partial<Config>;
    constructor(config?: Partial<Config>);
    /**
     * The easiest way how to add additional configuration from env variables, because
     * you cannot call method in RedshiftDriver.constructor before super.
     */
    protected getInitialConfiguration(): Partial<PostgresDriverConfiguration>;
    protected getTypeParser: (dataTypeID: TypeId, format: TypeFormat | undefined) => ((val: string) => string) | ((val: any) => any);
    /**
     * It's not possible to detect user defined types via constant oids
     * For example HLL extensions is using CREATE TYPE HLL which will generate a new pg_type with different oids
     */
    protected userDefinedTypes: Record<string, string> | null;
    protected getPostgresTypeForField(dataTypeID: number): string | null;
    testConnection(): Promise<void>;
    protected loadUserDefinedTypes(conn: PoolClient): Promise<void>;
    protected prepareConnection(conn: PoolClient, options?: {
        executionTimeout: number;
    }): Promise<void>;
    protected mapFields(fields: FieldDef[]): {
        name: string;
        type: string;
    }[];
    stream(query: string, values: unknown[], { highWaterMark }: StreamOptions): Promise<StreamTableDataWithTypes>;
    protected queryResponse(query: string, values: unknown[]): Promise<import("pg").QueryResult<any>>;
    query<R = unknown>(query: string, values: unknown[], options?: QueryOptions): Promise<R[]>;
    downloadQueryResults(query: string, values: unknown[], options: DownloadQueryResultsOptions): Promise<StreamTableDataWithTypes | {
        rows: any[];
        types: {
            name: string;
            type: string;
        }[];
    }>;
    toGenericType(columnType: string): GenericDataBaseType;
    readOnly(): boolean;
    uploadTableWithIndexes(table: string, columns: TableStructure, tableData: DownloadTableMemoryData, indexesSql: IndexesSQL): Promise<void>;
    release(): Promise<void>;
    param(paramIndex: number): string;
    fromGenericType(columnType: string): string;
}
//# sourceMappingURL=PostgresDriver.d.ts.map