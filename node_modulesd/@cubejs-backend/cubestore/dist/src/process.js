"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CubeStoreHandler = void 0;
const fs = __importStar(require("fs"));
const child_process_1 = require("child_process");
const shared_1 = require("@cubejs-backend/shared");
const download_1 = require("./download");
async function startProcess(pathToExecutable, config) {
    const env = {
        CUBESTORE_PORT: '13306',
        CUBESTORE_SELECT_WORKERS: '0',
    };
    if (process.env.CUBEJS_LOG_LEVEL === 'trace') {
        env.RUST_BACKTRACE = '1';
    }
    const cubeStore = child_process_1.spawn(pathToExecutable, {
        env,
        detached: false,
    });
    return new Promise((resolve, reject) => {
        /**
         * Default Continue Wait timeout in Orchestrator API is 5 seconds, It's not possible to use 15 seconds
         * because pooling will fire it again and again
         */
        const timeout = 4 * 1000;
        let startupExitListener = null;
        const startupTimeout = shared_1.withTimeout(() => {
            if (startupExitListener) {
                cubeStore.off('exit', startupExitListener);
            }
            // Let's kill it, because it's not able to start
            cubeStore.kill();
            reject(new Error(`Unable to start Cube Store, timeout after ${timeout / 1000}s`));
        }, timeout);
        startupExitListener = (code) => {
            startupTimeout.cancel();
            reject(new Error(`Cube Store exited with ${code} on startup.`));
        };
        cubeStore.on('exit', startupExitListener);
        const processExitListener = () => {
            process.off('exit', processExitListener);
            cubeStore.kill();
        };
        // Just a workaround for https://github.com/nodejs/node/issues/13538
        // It's ok because we dont use CubeStoreHandler.release with force = true
        process.on('exit', processExitListener);
        const startResolver = (data) => {
            if (data.toString().includes('MySQL port open on')) {
                // Clear startup timeout killer
                startupTimeout.cancel();
                // Disable start listener, because we resolve Promise
                cubeStore.stdout.off('data', startResolver);
                // Clear startup exit code listener
                if (startupExitListener) {
                    cubeStore.off('exit', startupExitListener);
                }
                // Restart can be done, if Cube Store started. Without it we change state to null status and wait next query.
                cubeStore.on('exit', (code) => {
                    process.off('exit', processExitListener);
                    config.onExit(code);
                });
                resolve(cubeStore);
            }
        };
        cubeStore.stdout.on('data', startResolver);
        cubeStore.stdout.on('data', config.stdout);
        cubeStore.stderr.on('data', config.stderr);
    });
}
class CubeStoreHandler {
    constructor(config) {
        this.config = config;
        this.cubeStore = null;
        // Promise that works as mutex, but can be rejected
        this.cubeStoreStarting = null;
        // Flag when release was requested, in this state, we skip restart on exit
        this.releaseRequested = false;
    }
    async getBinary() {
        const pathToExecutable = download_1.getBinaryPath();
        if (!fs.existsSync(pathToExecutable)) {
            await download_1.downloadBinaryFromRelease();
            if (!fs.existsSync(pathToExecutable)) {
                throw new Error('Something wrong with downloading Cube Store before running it.');
            }
        }
        return pathToExecutable;
    }
    async acquire() {
        if (this.cubeStore) {
            return this.cubeStore;
        }
        if (this.cubeStoreStarting) {
            return this.cubeStoreStarting;
        }
        const onExit = (code) => {
            if (this.releaseRequested) {
                return;
            }
            this.config.onRestart(code);
            this.cubeStoreStarting = new Promise((resolve, reject) => startProcess(download_1.getBinaryPath(), {
                ...this.config,
                onExit,
            }).then((cubeStore) => {
                this.cubeStore = cubeStore;
                this.cubeStoreStarting = null;
                resolve(cubeStore);
            }).catch((err) => {
                this.cubeStore = null;
                this.cubeStoreStarting = null;
                reject(err);
            }));
        };
        this.cubeStoreStarting = new Promise((resolve, reject) => this.getBinary()
            .then((pathToExecutable) => {
            startProcess(pathToExecutable, {
                ...this.config,
                onExit,
            }).then((cubeStore) => {
                this.cubeStore = cubeStore;
                this.cubeStoreStarting = null;
                resolve(cubeStore);
            }).catch((err) => {
                this.cubeStore = null;
                this.cubeStoreStarting = null;
                reject(err);
            });
        })
            .catch((err) => {
            this.cubeStore = null;
            this.cubeStoreStarting = null;
            reject(err);
        }));
        return this.cubeStoreStarting;
    }
    async release(force = false) {
        // Force, is a compatibility flag, for now we release only in tests
        if (force) {
            if (this.cubeStoreStarting) {
                throw new Error('Something wrong with logic, release was called, while cubestore is starting...');
            }
            this.releaseRequested = true;
            if (this.cubeStore) {
                this.cubeStore.kill('SIGTERM');
            }
        }
    }
}
exports.CubeStoreHandler = CubeStoreHandler;
//# sourceMappingURL=process.js.map