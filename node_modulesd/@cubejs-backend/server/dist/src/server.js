"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CubejsServer = void 0;
const dotenv_1 = __importDefault(require("@cubejs-backend/dotenv"));
const server_core_1 = __importDefault(require("@cubejs-backend/server-core"));
const shared_1 = require("@cubejs-backend/shared");
const express_1 = __importDefault(require("express"));
const http_1 = __importDefault(require("http"));
const util_1 = __importDefault(require("util"));
const body_parser_1 = __importDefault(require("body-parser"));
const cors_1 = __importDefault(require("cors"));
const websocket_server_1 = require("./websocket-server");
const gracefull_http_1 = require("./server/gracefull-http");
const graceful_middleware_1 = require("./graceful-middleware");
const server_status_1 = require("./server-status");
const { version } = require('../../package.json');
dotenv_1.default.config({
    multiline: 'line-breaks',
});
class CubejsServer {
    constructor(config = {}, systemOptions) {
        var _a;
        this.server = null;
        this.socketServer = null;
        this.sqlServer = null;
        this.status = new server_status_1.ServerStatusHandler();
        this.config = {
            ...config,
            webSockets: config.webSockets || shared_1.getEnv('webSockets'),
            sqlPort: config.sqlPort || shared_1.getEnv('sqlPort'),
            http: {
                ...config.http,
                cors: {
                    allowedHeaders: 'authorization,content-type,x-request-id',
                    ...(_a = config.http) === null || _a === void 0 ? void 0 : _a.cors
                }
            },
        };
        this.core = server_core_1.default.create(config, systemOptions);
        this.server = null;
    }
    async listen(options = {}) {
        try {
            if (this.server) {
                throw new Error('CubeServer is already listening');
            }
            const app = express_1.default();
            app.use(cors_1.default(this.config.http.cors));
            app.use(body_parser_1.default.json({ limit: '50mb' }));
            if (this.config.gracefulShutdown) {
                app.use(graceful_middleware_1.gracefulMiddleware(this.status, this.config.gracefulShutdown));
            }
            if (this.config.initApp) {
                await this.config.initApp(app);
            }
            await this.core.initApp(app);
            const enableTls = shared_1.getEnv('tls');
            if (enableTls) {
                throw new Error('CUBEJS_ENABLE_TLS has been deprecated and removed.');
            }
            this.server = gracefull_http_1.gracefulHttp(http_1.default.createServer(options, app));
            if (this.config.webSockets) {
                this.socketServer = new websocket_server_1.WebSocketServer(this.core, this.config);
                this.socketServer.initServer(this.server);
            }
            if (this.config.sqlPort) {
                this.sqlServer = this.core.initSQLServer();
                await this.sqlServer.init(this.config);
            }
            const PORT = shared_1.getEnv('port');
            await this.server.listen(PORT);
            return {
                app,
                port: PORT,
                server: this.server,
                version
            };
        }
        catch (e) {
            if (this.core.event) {
                await this.core.event('Dev Server Fatal Error', {
                    error: (e.stack || e.message || e).toString()
                });
            }
            throw e;
        }
    }
    testConnections() {
        return this.core.testConnections();
    }
    // @internal
    handleScheduledRefreshInterval(options) {
        return this.core.handleScheduledRefreshInterval(options);
    }
    // @internal
    runScheduledRefresh(context, queryingOptions) {
        return this.core.runScheduledRefresh(context, queryingOptions);
    }
    // @internal
    async getDriver(ctx) {
        return this.core.getDriver(ctx);
    }
    async close() {
        try {
            if (this.socketServer) {
                await this.socketServer.close();
            }
            if (this.sqlServer) {
                await this.sqlServer.close();
            }
            if (!this.server) {
                throw new Error('CubeServer is not started.');
            }
            await util_1.default.promisify(this.server.close)();
            this.server = null;
            await this.core.releaseConnections();
        }
        catch (e) {
            if (this.core.event) {
                await this.core.event('Dev Server Fatal Error', {
                    error: (e.stack || e.message || e).toString()
                });
            }
            throw e;
        }
    }
    static createDriver(dbType) {
        return server_core_1.default.createDriver(dbType);
    }
    static driverDependencies(dbType) {
        return server_core_1.default.driverDependencies(dbType);
    }
    static apiSecret() {
        return process.env.CUBEJS_API_SECRET;
    }
    static version() {
        return version;
    }
    async shutdown(signal, graceful = true) {
        try {
            const timeoutKiller = shared_1.withTimeout(() => {
                this.core.logger('Graceful Shutdown Timeout Kill', {
                    error: 'Unable to stop Cube.js in expected time, force kill',
                });
                process.exit(1);
            }, 
            // this.server.stop can be closed in this.config.gracefulShutdown, let's add 1s before kill
            ((this.config.gracefulShutdown || 2) + 1) * 1000);
            this.status.shutdown();
            const locks = [
                this.core.beforeShutdown()
            ];
            if (this.socketServer) {
                locks.push(this.socketServer.close());
            }
            if (this.server) {
                locks.push(this.server.stop((this.config.gracefulShutdown || 2) * 1000));
            }
            if (graceful) {
                // Await before all connections/refresh scheduler will end jobs
                await Promise.all(locks);
            }
            await this.core.shutdown();
            await timeoutKiller.cancel();
            return 0;
        }
        catch (e) {
            console.error('Fatal error during server shutting down: ');
            console.error(e.stack || e);
            return 1;
        }
    }
}
exports.CubejsServer = CubejsServer;
//# sourceMappingURL=server.js.map