"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebSocketServer = void 0;
const ws_1 = __importDefault(require("ws"));
const crypto_1 = __importDefault(require("crypto"));
const util_1 = __importDefault(require("util"));
const shared_1 = require("@cubejs-backend/shared");
class WebSocketServer {
    constructor(serverCore, options = {}) {
        this.serverCore = serverCore;
        this.options = options;
        this.subscriptionsTimer = null;
        this.wsServer = null;
        this.subscriptionServer = null;
    }
    initServer(server) {
        this.wsServer = new ws_1.default.Server({
            server,
            path: this.options.webSocketsBasePath,
        });
        const connectionIdToSocket = {};
        this.subscriptionServer = this.serverCore.initSubscriptionServer((connectionId, message) => {
            if (!connectionIdToSocket[connectionId]) {
                throw new Error(`Socket for ${connectionId} is not found found`);
            }
            connectionIdToSocket[connectionId].send(JSON.stringify(message));
        });
        this.wsServer.on('connection', (ws) => {
            const connectionId = crypto_1.default.randomBytes(8).toString('hex');
            connectionIdToSocket[connectionId] = ws;
            ws.on('message', async (message) => {
                await this.subscriptionServer.processMessage(connectionId, message, true);
            });
            ws.on('close', async () => {
                await this.subscriptionServer.disconnect(connectionId);
            });
            ws.on('error', async () => {
                await this.subscriptionServer.disconnect(connectionId);
            });
        });
        const processSubscriptionsInterval = this.options.processSubscriptionsInterval || 5 * 1000;
        this.subscriptionsTimer = shared_1.createCancelableInterval(async () => {
            await this.subscriptionServer.processSubscriptions();
        }, {
            interval: processSubscriptionsInterval,
            onDuplicatedExecution: (intervalId) => this.serverCore.logger('WebSocket Server Interval Error', {
                error: `Previous interval #${intervalId} was not finished with ${processSubscriptionsInterval} interval`
            }),
        });
    }
    async close() {
        if (this.subscriptionsTimer) {
            await this.subscriptionsTimer.cancel();
        }
        if (this.wsServer) {
            const close = util_1.default.promisify(this.wsServer.close.bind(this.wsServer));
            await close();
        }
        this.subscriptionServer.clear();
    }
}
exports.WebSocketServer = WebSocketServer;
//# sourceMappingURL=websocket-server.js.map