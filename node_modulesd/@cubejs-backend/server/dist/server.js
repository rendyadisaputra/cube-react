"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CubejsServer = void 0;
const dotenv_1 = __importDefault(require("dotenv"));
const server_core_1 = __importDefault(require("@cubejs-backend/server-core"));
const shared_1 = require("@cubejs-backend/shared");
const express_1 = __importDefault(require("express"));
const https_1 = __importDefault(require("https"));
const http_1 = __importDefault(require("http"));
const util_1 = __importDefault(require("util"));
const body_parser_1 = __importDefault(require("body-parser"));
const cors_1 = __importDefault(require("cors"));
const websocket_server_1 = require("./websocket-server");
const { version } = require('../package.json');
dotenv_1.default.config();
class CubejsServer {
    constructor(config = {}) {
        var _a;
        this.redirector = null;
        this.server = null;
        this.socketServer = null;
        this.config = Object.assign(Object.assign({}, config), { webSockets: config.webSockets || shared_1.getEnv('webSockets'), http: Object.assign(Object.assign({}, config.http), { cors: Object.assign({ allowedHeaders: 'authorization,content-type,x-request-id' }, (_a = config.http) === null || _a === void 0 ? void 0 : _a.cors) }) });
        this.core = server_core_1.default.create(config);
        this.redirector = null;
        this.server = null;
    }
    async listen(options = {}) {
        try {
            if (this.server) {
                throw new Error('CubeServer is already listening');
            }
            const app = express_1.default();
            app.use(cors_1.default(this.config.http.cors));
            app.use(body_parser_1.default.json({ limit: '50mb' }));
            if (this.config.initApp) {
                await this.config.initApp(app);
            }
            await this.core.initApp(app);
            const PORT = shared_1.getEnv('port');
            const TLS_PORT = shared_1.getEnv('tlsPort');
            const enableTls = shared_1.getEnv('tls');
            if (enableTls) {
                process.emitWarning('Environment variable CUBEJS_ENABLE_TLS was deprecated and will be removed. \n' +
                    'Use own reverse proxy in front of Cube.js for proxying HTTPS traffic.', 'DeprecationWarning');
                this.redirector = http_1.default.createServer((req, res) => {
                    if (req.headers.host) {
                        res.writeHead(301, {
                            Location: `https://${req.headers.host.split(':')[0]}:${TLS_PORT}${req.url}`
                        });
                    }
                    res.end();
                });
                this.redirector.listen(PORT);
            }
            if (enableTls) {
                this.server = https_1.default.createServer(options, app);
            }
            else {
                const [major] = process.version.split('.');
                if (major === '8' && Object.keys(options).length) {
                    process.emitWarning('There is no support for passing options inside listen method in Node.js 8.', 'CustomWarning');
                    this.server = http_1.default.createServer(app);
                }
                else {
                    this.server = http_1.default.createServer(options, app);
                }
            }
            if (this.config.webSockets) {
                this.socketServer = new websocket_server_1.WebSocketServer(this.core, this.core.options);
                this.socketServer.initServer(this.server);
            }
            await this.server.listen(enableTls ? TLS_PORT : PORT);
            return {
                app,
                port: PORT,
                tlsPort: enableTls ? TLS_PORT : undefined,
                server: this.server,
                version
            };
        }
        catch (e) {
            if (this.core.event) {
                await this.core.event('Dev Server Fatal Error', {
                    error: (e.stack || e.message || e).toString()
                });
            }
            throw e;
        }
    }
    testConnections() {
        return this.core.testConnections();
    }
    runScheduledRefresh(context, queryingOptions) {
        return this.core.runScheduledRefresh(context, queryingOptions);
    }
    async close() {
        try {
            if (this.socketServer) {
                await this.socketServer.close();
            }
            if (!this.server) {
                throw new Error('CubeServer is not started.');
            }
            await util_1.default.promisify(this.server.close)();
            this.server = null;
            if (this.redirector) {
                await util_1.default.promisify(this.redirector.close)();
                this.redirector = null;
            }
            await this.core.releaseConnections();
        }
        catch (e) {
            if (this.core.event) {
                await this.core.event('Dev Server Fatal Error', {
                    error: (e.stack || e.message || e).toString()
                });
            }
            throw e;
        }
    }
    static createDriver(dbType) {
        return server_core_1.default.createDriver(dbType);
    }
    static driverDependencies(dbType) {
        return server_core_1.default.driverDependencies(dbType);
    }
    static apiSecret() {
        return process.env.CUBEJS_API_SECRET;
    }
    static version() {
        return version;
    }
}
exports.CubejsServer = CubejsServer;
//# sourceMappingURL=server.js.map