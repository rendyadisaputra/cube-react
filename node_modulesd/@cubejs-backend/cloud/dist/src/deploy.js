"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeployController = exports.DeployDirectory = void 0;
const crypto_1 = __importDefault(require("crypto"));
const path_1 = __importDefault(require("path"));
const fs_extra_1 = __importDefault(require("fs-extra"));
class DeployDirectory {
    constructor(options) {
        this.options = options;
    }
    async fileHashes(directory = this.options.directory) {
        let result = {};
        const files = await fs_extra_1.default.readdir(directory);
        // eslint-disable-next-line no-restricted-syntax
        for (const file of files) {
            const filePath = path_1.default.resolve(directory, file);
            if (!this.filter(filePath)) {
                // eslint-disable-next-line no-continue
                continue;
            }
            const stat = await fs_extra_1.default.stat(filePath);
            if (stat.isDirectory()) {
                result = { ...result, ...await this.fileHashes(filePath) };
            }
            else {
                result[path_1.default.relative(this.options.directory, filePath)] = {
                    hash: await this.fileHash(filePath)
                };
            }
        }
        return result;
    }
    filter(file) {
        const baseName = path_1.default.basename(file);
        // whitelist
        if (['.gitignore'].includes(baseName)) {
            return true;
        }
        // blacklist
        if (['dashboard-app', 'node_modules'].includes(baseName)) {
            return false;
        }
        return baseName.charAt(0) !== '.';
    }
    fileHash(file) {
        return new Promise((resolve, reject) => {
            const hash = crypto_1.default.createHash('sha1');
            const stream = fs_extra_1.default.createReadStream(file);
            stream.on('error', err => reject(err));
            stream.on('data', chunk => hash.update(chunk));
            stream.on('end', () => resolve(hash.digest('hex')));
        });
    }
}
exports.DeployDirectory = DeployDirectory;
class DeployController {
    constructor(cubeCloudClient, hooks = {}) {
        this.cubeCloudClient = cubeCloudClient;
        this.hooks = hooks;
    }
    async deploy(directory) {
        let result;
        const deployDir = new DeployDirectory({ directory });
        const fileHashes = await deployDir.fileHashes();
        const upstreamHashes = await this.cubeCloudClient.getUpstreamHashes();
        const { transaction, deploymentName } = await this.cubeCloudClient.startUpload();
        const files = Object.keys(fileHashes);
        const fileHashesPosix = {};
        if (this.hooks.onStart)
            this.hooks.onStart(deploymentName, files);
        try {
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                if (this.hooks.onUpdate)
                    this.hooks.onUpdate(i, { file });
                const filePosix = file.split(path_1.default.sep).join(path_1.default.posix.sep);
                fileHashesPosix[filePosix] = fileHashes[file];
                if (!upstreamHashes[filePosix] || upstreamHashes[filePosix].hash !== fileHashes[file].hash) {
                    if (this.hooks.onUpload)
                        this.hooks.onUpload(files, file);
                    await this.cubeCloudClient.uploadFile({
                        transaction,
                        fileName: filePosix,
                        data: fs_extra_1.default.createReadStream(path_1.default.join(directory, file))
                    });
                }
            }
            result = await this.cubeCloudClient.finishUpload({ transaction, files: fileHashesPosix });
        }
        finally {
            if (this.hooks.onFinally)
                this.hooks.onFinally();
        }
        return result || {};
    }
}
exports.DeployController = DeployController;
//# sourceMappingURL=deploy.js.map