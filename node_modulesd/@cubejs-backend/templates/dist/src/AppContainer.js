"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppContainer = void 0;
const ramda_1 = __importDefault(require("ramda"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const shared_1 = require("@cubejs-backend/shared");
const utils_1 = require("./utils");
const SourceContainer_1 = require("./SourceContainer");
class AppContainer {
    constructor(rootNode, { appPath, packagesPath }, playgroundContext) {
        this.rootNode = rootNode;
        this.sourceContainer = null;
        this.playgroundContext = playgroundContext;
        this.appPath = appPath;
        this.packagesPath = packagesPath;
        this.initDependencyTree();
    }
    static getPackageVersions(appPath) {
        try {
            return fs_extra_1.default.readJsonSync(path_1.default.join(appPath, 'package.json')).cubejsTemplates || {};
        }
        catch (error) {
            return {};
        }
    }
    async applyTemplates() {
        this.sourceContainer = await this.loadSources();
        await this.rootNode.packageInstance.applyPackage(this.sourceContainer);
    }
    initDependencyTree() {
        this.createInstances(this.rootNode);
        this.setChildren(this.rootNode);
    }
    setChildren(node) {
        if (!node) {
            return;
        }
        node.children.forEach((currentNode) => {
            this.setChildren(currentNode);
            const [installsTo] = Object.keys(currentNode.package.installsTo);
            if (!node.packageInstance.children[installsTo]) {
                node.packageInstance.children[installsTo] = [];
            }
            node.packageInstance.children[installsTo].push(currentNode.packageInstance);
        });
    }
    createInstances(node) {
        const stack = [node];
        while (stack.length) {
            const child = stack.pop();
            const scaffoldingPath = path_1.default.join(this.packagesPath, child.package.name, 'scaffolding');
            // eslint-disable-next-line
            const instance = require(path_1.default.join(this.packagesPath, child.package.name))({
                appContainer: this,
                package: {
                    ...child.package,
                    scaffoldingPath,
                },
                playgroundContext: this.playgroundContext,
            });
            child.packageInstance = instance;
            child.children.forEach((currentChild) => {
                stack.push(currentChild);
            });
        }
    }
    async loadSources() {
        return new SourceContainer_1.SourceContainer(await utils_1.fileContentsRecursive(this.appPath));
    }
    async persistSources(sourceContainer, packageVersions) {
        const sources = sourceContainer.outputSources();
        await Promise.all(sources.map((file) => fs_extra_1.default.outputFile(path_1.default.join(this.appPath, file.fileName), file.content)));
        await Promise.all(Object.entries(sourceContainer.filesToMove).map(async ([from, to]) => {
            try {
                await this.executeCommand(`cp ${from} ${path_1.default.join('.', to)}`, [], {
                    shell: true,
                    cwd: path_1.default.resolve(this.appPath),
                });
            }
            catch (error) {
                console.log(`Unable to copy file: ${from} -> ${to}`);
            }
        }));
        try {
            const packageJson = fs_extra_1.default.readJsonSync(path_1.default.join(this.appPath, 'package.json'));
            packageJson.cubejsTemplates = {
                ...packageJson.cubejsTemplates,
                ...packageVersions,
            };
            await fs_extra_1.default.writeJson(path_1.default.join(this.appPath, 'package.json'), packageJson, {
                spaces: 2,
            });
        }
        catch (_) {
            //
        }
    }
    async executeCommand(command, args, options) {
        return shared_1.executeCommand(command, args, options);
    }
    async ensureDependencies() {
        var _a;
        const dependencies = ((_a = this.sourceContainer) === null || _a === void 0 ? void 0 : _a.importDependencies) || [];
        let packageJson;
        try {
            packageJson = fs_extra_1.default.readJsonSync(path_1.default.join(this.appPath, 'package.json'));
        }
        catch (_) {
            //
        }
        if (!packageJson || !packageJson.dependencies) {
            return [];
        }
        const toInstall = ramda_1.default.toPairs(dependencies)
            .map(([dependency, version]) => {
            const currentDependency = version !== 'latest' ? `${dependency}@${version}` : dependency;
            if (!packageJson.dependencies[dependency] || version !== 'latest') {
                return currentDependency;
            }
            return false;
        })
            .filter(Boolean);
        if (toInstall.length) {
            await this.executeCommand('npm', ['install', '--save'].concat(toInstall), { cwd: path_1.default.resolve(this.appPath) });
        }
        return toInstall;
    }
    getPackageVersions() {
        return AppContainer.getPackageVersions(this.appPath);
    }
}
exports.AppContainer = AppContainer;
//# sourceMappingURL=AppContainer.js.map