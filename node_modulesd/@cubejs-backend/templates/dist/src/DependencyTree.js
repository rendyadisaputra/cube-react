"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DependencyTree = void 0;
const ramda_1 = __importDefault(require("ramda"));
const indexByName = (packages) => ramda_1.default.indexBy(ramda_1.default.prop('name'), packages);
class DependencyTree {
    constructor(manifest, templatePackages) {
        this.manifest = manifest;
        this.templatePackages = templatePackages;
        this.rootNode = null;
        this.resolved = [];
        this.build(this.getRootNode());
        const diff = ramda_1.default.difference(templatePackages, this.resolved);
        if (diff.length) {
            throw new Error(`The following packages could not be resolved: ${diff.join(', ')}`);
        }
    }
    packages() {
        return this.manifest.packages;
    }
    getRootNode() {
        if (this.rootNode) {
            return this.rootNode;
        }
        const rootPackages = this.packages().filter((pkg) => pkg.installsTo == null);
        const root = rootPackages.find((pkg) => this.templatePackages.includes(pkg.name));
        if (!root) {
            throw new Error('root package not found');
        }
        this.resolved.push(root.name);
        this.rootNode = {
            package: root,
            children: [],
        };
        return this.rootNode;
    }
    packagesInstalledTo(name) {
        return indexByName(this.packages().filter((pkg) => (pkg.installsTo || {})[name]));
    }
    getChildren(pkg) {
        const children = [];
        Object.keys(pkg.receives || {}).forEach((receive) => {
            const currentPackages = this.packagesInstalledTo(receive);
            if (Object.keys(currentPackages || {}).length) {
                this.templatePackages.forEach((name) => {
                    if (currentPackages[name]) {
                        children.push(currentPackages[name]);
                    }
                });
            }
        });
        return children;
    }
    build(node) {
        if (!node) {
            return;
        }
        (this.getChildren(node.package) || []).forEach((child) => {
            const childNode = {
                package: child,
                children: [],
            };
            node.children.push(childNode);
            this.resolved.push(child.name);
            this.build(childNode);
        });
    }
}
exports.DependencyTree = DependencyTree;
//# sourceMappingURL=DependencyTree.js.map