"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageFetcher = void 0;
const fs_extra_1 = __importDefault(require("fs-extra"));
const decompress_1 = __importDefault(require("decompress"));
const decompress_targz_1 = __importDefault(require("decompress-targz"));
const path_1 = __importDefault(require("path"));
const shared_1 = require("@cubejs-backend/shared");
const utils_1 = require("./utils");
class PackageFetcher {
    constructor(repo) {
        this.repo = repo;
        this.tmpFolderPath = path_1.default.resolve('.', 'node_modules', '.tmp');
        this.init();
        this.repoArchivePath = `${this.tmpFolderPath}/master.tar.gz`;
    }
    init() {
        try {
            // Folder node_modules does not exist by default inside docker in /cube/conf without sharing volume for it
            fs_extra_1.default.mkdirpSync(this.tmpFolderPath);
        }
        catch (err) {
            if (err.code === 'EEXIST') {
                this.cleanup();
                fs_extra_1.default.mkdirSync(this.tmpFolderPath);
            }
            else {
                throw err;
            }
        }
    }
    async manifestJSON() {
        const response = await utils_1.proxyFetch(`https://api.github.com/repos/${this.repo.owner}/${this.repo.name}/contents/manifest.json`);
        return JSON.parse(Buffer.from((await response.json()).content, 'base64').toString());
    }
    async downloadRepo() {
        const url = `https://github.com/${this.repo.owner}/${this.repo.name}/archive/master.tar.gz`;
        const writer = fs_extra_1.default.createWriteStream(this.repoArchivePath);
        (await utils_1.proxyFetch(url)).body.pipe(writer);
        return new Promise((resolve, reject) => {
            writer.on('finish', resolve);
            writer.on('error', reject);
        });
    }
    async downloadPackages() {
        await this.downloadRepo();
        await decompress_1.default(this.repoArchivePath, this.tmpFolderPath, {
            plugins: [decompress_targz_1.default()],
        });
        const dir = fs_extra_1.default.readdirSync(this.tmpFolderPath).find((name) => !name.endsWith('tar.gz'));
        if (!dir) {
            throw new Error('No directory found');
        }
        fs_extra_1.default.removeSync(path_1.default.resolve(this.tmpFolderPath, dir, 'yarn.lock'));
        await shared_1.executeCommand('npm', ['install'], { cwd: path_1.default.resolve(this.tmpFolderPath, dir) });
        return {
            packagesPath: path_1.default.join(this.tmpFolderPath, dir, 'packages'),
        };
    }
    cleanup() {
        fs_extra_1.default.removeSync(this.tmpFolderPath);
    }
}
exports.PackageFetcher = PackageFetcher;
//# sourceMappingURL=PackageFetcher.js.map